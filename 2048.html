<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Game with AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#8B4513',
                        secondary: '#A0522D'
                    },
                    borderRadius: {
                        'none': '0px',
                        'sm': '4px',
                        DEFAULT: '8px',
                        'md': '12px',
                        'lg': '16px',
                        'xl': '20px',
                        '2xl': '24px',
                        '3xl': '32px',
                        'full': '9999px',
                        'button': '8px'
                    }
                }
            }
        }
    </script>
    <style>
        :where([class^="ri-"])::before {
            content: "\f3c2";
        }

        .tile {
            transition: all 0.15s ease-in-out;
            background: #CDC1B4;
            color: #776E65;
            font-weight: bold;
            font-size: 1.5rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .tile-2 {
            background: #EEE4DA;
        }

        .tile-4 {
            background: #EDE0C8;
        }

        .tile-8 {
            background: #F2B179;
            color: #F9F6F2;
        }

        .tile-16 {
            background: #F59563;
            color: #F9F6F2;
        }

        .tile-32 {
            background: #F67C5F;
            color: #F9F6F2;
        }

        .tile-64 {
            background: #F65E3B;
            color: #F9F6F2;
        }

        .tile-128 {
            background: #EDCF72;
            color: #F9F6F2;
            font-size: 1.3rem;
        }

        .tile-256 {
            background: #EDCC61;
            color: #F9F6F2;
            font-size: 1.3rem;
        }

        .tile-512 {
            background: #EDC850;
            color: #F9F6F2;
            font-size: 1.3rem;
        }

        .tile-1024 {
            background: #EDC53F;
            color: #F9F6F2;
            font-size: 1.1rem;
        }

        .tile-2048 {
            background: #EDC22E;
            color: #F9F6F2;
            font-size: 1.1rem;
        }

        .game-container {
            touch-action: none;
            user-select: none;
        }

        @keyframes slide-in {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }

        .new-tile {
            animation: slide-in 0.2s ease-in-out;
        }
    </style>
</head>

<body class="bg-[#FAF8EF] min-h-screen">
    <div id="app" class="container mx-auto px-4 py-4 max-w-3xl h-[100vh]">
        <div id="mode-selection"
            class="h-[100vh] flex flex-col items-center justify-center bg-gradient-to-br from-[#FAF8EF] to-[#EEE4DA]">
            <div class="text-center max-w-2xl mx-auto px-4">
                <div class="mb-8">
                    <h1
                        class="text-6xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent mb-4">
                        2048</h1>
                    <p class="text-gray-600 text-base mb-6">Challenge yourself in this addictive number puzzle game.
                        Combine tiles, reach 2048!</p>
                </div>
                <div class="grid gap-6 max-w-md mx-auto">
                    <button onclick="startGame('human')"
                        class="group relative overflow-hidden px-6 py-4 bg-primary text-white font-semibold !rounded-xl hover:shadow-lg hover:scale-105 transition-all duration-300">
                        <div class="flex items-center justify-center gap-3">
                            <i class="ri-user-line ri-xl"></i>
                            <span class="text-xl">Play as Human</span>
                        </div>
                        <div
                            class="absolute inset-0 bg-white opacity-0 group-hover:opacity-10 transition-opacity duration-300">
                        </div>
                    </button>
                    <button onclick="startGame('ai')"
                        class="group relative overflow-hidden px-6 py-4 bg-secondary text-white font-semibold !rounded-xl hover:shadow-lg hover:scale-105 transition-all duration-300">
                        <div class="flex items-center justify-center gap-3">
                            <i class="ri-robot-line ri-xl"></i>
                            <span class="text-xl">Watch AI Play</span>
                        </div>
                        <div
                            class="absolute inset-0 bg-white opacity-0 group-hover:opacity-10 transition-opacity duration-300">
                        </div>
                    </button>
                </div>
                <div class="mt-8 text-gray-500">
                    <p class="text-sm">Use arrow keys or swipe to move tiles</p>
                    <div class="flex justify-center gap-2 mt-3">
                        <i class="ri-arrow-up-line"></i>
                        <i class="ri-arrow-right-line"></i>
                        <i class="ri-arrow-down-line"></i>
                        <i class="ri-arrow-left-line"></i>
                    </div>
                </div>
            </div>
        </div>
        <div id="game-board" class="hidden">
            <div class="flex justify-between items-center mb-8">
                <button onclick="backToMenu()"
                    class="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium flex items-center gap-2">
                    <i class="ri-arrow-left-line"></i>
                    Back
                </button>
                <div class="flex gap-4">
                    <div class="bg-[#BBADA0] text-white rounded p-2 shadow-lg">
                        <div class="text-xs text-[#EEE4DA]">SCORE</div>
                        <div id="score" class="text-xl font-bold text-white">0</div>
                    </div>
                    <div class="bg-[#BBADA0] text-white rounded p-2 shadow-lg">
                        <div class="text-xs text-[#EEE4DA]">BEST</div>
                        <div id="best-score" class="text-xl font-bold text-white">0</div>
                    </div>
                </div>
            </div>
            <div id="ai-controls" class="hidden mb-6">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-4">
                        <button id="ai-toggle" onclick="toggleAI()"
                            class="px-6 py-2 bg-secondary text-white font-medium !rounded-button hover:bg-opacity-90">
                            Start AI
                        </button>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="ai-speed" class="hidden" onchange="toggleAISpeed()">
                            <div class="w-10 h-6 bg-gray-300 rounded-full p-1 duration-300 ease-in-out relative">
                                <div class="w-4 h-4 bg-white rounded-full shadow-md transform duration-300 ease-in-out">
                                </div>
                            </div>
                            <span class="text-gray-600 text-sm">Turbo Mode</span>
                        </label>
                    </div>
                    <div id="ai-status" class="text-gray-600">Ready</div>
                </div>
            </div>
            <div class="game-container bg-[#BBADA0] p-4 rounded-lg shadow-xl w-[500px] mx-auto">
                <div class="grid grid-cols-4 gap-4">
                    <div class="aspect-square bg-[#CCC0B3] rounded flex items-center justify-center tile h-[100px]">
                    </div>
                    <div class="aspect-square bg-[#CCC0B3] rounded flex items-center justify-center tile h-[100px]">
                    </div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                    <div class="aspect-square bg-[#CDC1B4] rounded flex items-center justify-center tile"></div>
                </div>
            </div>
            <div class="flex justify-center gap-4 mt-8 mb-4">
                <button onclick="resetGame()"
                    class="px-6 py-2 bg-gray-200 text-gray-700 font-medium !rounded-button hover:bg-gray-300">
                    New Game
                </button>
                <button onclick="undoMove()" id="undo-btn"
                    class="px-6 py-2 bg-gray-200 text-gray-700 font-medium !rounded-button hover:bg-gray-300">
                    Undo
                </button>
            </div>
        </div>
        <div id="game-over" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
            <div class="bg-white p-8 rounded-lg text-center">
                <h2 class="text-3xl font-bold text-gray-800 mb-4">Game Over!</h2>
                <div class="text-xl text-gray-600 mb-6">
                    Score: <span id="final-score">0</span>
                </div>
                <div class="space-y-4">
                    <button onclick="resetGame()"
                        class="w-full px-6 py-3 bg-primary text-white font-medium !rounded-button hover:bg-opacity-90">
                        Try Again
                    </button>
                    <button onclick="backToMenu()"
                        class="w-full px-6 py-3 bg-gray-200 text-gray-700 font-medium !rounded-button hover:bg-gray-300">
                        Back to Menu
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        let gameState = {
            board: Array(16).fill(0),
            score: 0,
            bestScore: parseInt(localStorage.getItem('bestScore')) || 0,
            gameMode: null,
            previousStates: [],
            aiRunning: false,
            aiInterval: null
        };
        function startGame(mode) {
            gameState.gameMode = mode;
            document.getElementById('mode-selection').classList.add('hidden');
            document.getElementById('game-board').classList.remove('hidden');
            if (mode === 'ai') {
                document.getElementById('ai-controls').classList.remove('hidden');
                document.getElementById('undo-btn').classList.add('hidden');
            }
            resetGame();
        }
        function backToMenu() {
            document.getElementById('mode-selection').classList.remove('hidden');
            document.getElementById('game-board').classList.add('hidden');
            document.getElementById('game-over').classList.add('hidden');
            if (gameState.aiRunning) {
                toggleAI();
            }
        }
        function resetGame() {
            gameState.board = Array(16).fill(0);
            gameState.score = 0;
            gameState.previousStates = [];
            updateScore();
            addNewTile();
            addNewTile();
            document.getElementById('game-over').classList.add('hidden');
            renderBoard();
        }
        function addNewTile() {
            const emptyCells = gameState.board.reduce((acc, val, idx) => {
                if (val === 0) acc.push(idx);
                return acc;
            }, []);
            if (emptyCells.length) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                gameState.board[randomCell] = Math.random() < 0.9 ? 2 : 4;
            }
        }
        function renderBoard() {
            const tiles = document.querySelectorAll('.tile');
            gameState.board.forEach((value, index) => {
                tiles[index].textContent = value || '';
                tiles[index].className = `aspect-square rounded flex items-center justify-center tile ${value ? 'tile-' + value : 'bg-gray-200'}`;
                if (value) tiles[index].classList.add('new-tile');
            });
        }
        function updateScore() {
            document.getElementById('score').textContent = gameState.score;
            if (gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem('bestScore', gameState.bestScore);
                document.getElementById('best-score').textContent = gameState.bestScore;
            }
        }
        function move(direction) {
            const previousBoard = [...gameState.board];
            const previousScore = gameState.score;
            let moved = false;
            let merged = Array(16).fill(false);
            if (direction === 'left' || direction === 'right') {
                for (let row = 0; row < 4; row++) {
                    const line = [];
                    for (let col = 0; col < 4; col++) {
                        const value = gameState.board[row * 4 + col];
                        if (value) line.push(value);
                    }
                    if (direction === 'right') line.reverse();
                    for (let i = 0; i < line.length - 1; i++) {
                        if (line[i] === line[i + 1]) {
                            line[i] *= 2;
                            gameState.score += line[i];
                            line.splice(i + 1, 1);
                            moved = true;
                        }
                    }
                    while (line.length < 4) line.push(0);
                    if (direction === 'right') line.reverse();
                    for (let col = 0; col < 4; col++) {
                        if (gameState.board[row * 4 + col] !== line[col]) {
                            moved = true;
                        }
                        gameState.board[row * 4 + col] = line[col];
                    }
                }
            } else {
                for (let col = 0; col < 4; col++) {
                    const line = [];
                    for (let row = 0; row < 4; row++) {
                        const value = gameState.board[row * 4 + col];
                        if (value) line.push(value);
                    }
                    if (direction === 'down') line.reverse();
                    for (let i = 0; i < line.length - 1; i++) {
                        if (line[i] === line[i + 1]) {
                            line[i] *= 2;
                            gameState.score += line[i];
                            line.splice(i + 1, 1);
                            moved = true;
                        }
                    }
                    while (line.length < 4) line.push(0);
                    if (direction === 'down') line.reverse();
                    for (let row = 0; row < 4; row++) {
                        if (gameState.board[row * 4 + col] !== line[row]) {
                            moved = true;
                        }
                        gameState.board[row * 4 + col] = line[row];
                    }
                }
            }
            if (moved) {
                gameState.previousStates.push({
                    board: previousBoard,
                    score: previousScore
                });
                addNewTile();
                updateScore();
                renderBoard();
                if (!canMove()) {
                    gameOver();
                }
            }
            return moved;
        }
        function canMove() {
            for (let i = 0; i < 16; i++) {
                if (gameState.board[i] === 0) return true;
                const row = Math.floor(i / 4);
                const col = i % 4;
                if (col < 3 && gameState.board[i] === gameState.board[i + 1]) return true;
                if (row < 3 && gameState.board[i] === gameState.board[i + 4]) return true;
            }
            return false;
        }
        function gameOver() {
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('final-score').textContent = gameState.score;
            if (gameState.aiRunning) {
                toggleAI();
            }
        }
        function undoMove() {
            if (gameState.previousStates.length && gameState.gameMode === 'human') {
                const previousState = gameState.previousStates.pop();
                gameState.board = previousState.board;
                gameState.score = previousState.score;
                updateScore();
                renderBoard();
            }
        }
        function toggleAI() {
            gameState.aiRunning = !gameState.aiRunning;
            const button = document.getElementById('ai-toggle');
            const status = document.getElementById('ai-status');
            const speedCheckbox = document.getElementById('ai-speed');
            if (gameState.aiRunning) {
                button.textContent = 'Stop AI';
                button.classList.remove('bg-secondary');
                button.classList.add('bg-red-500');
                status.textContent = 'Running';
                runAI();
            } else {
                button.textContent = 'Start AI';
                button.classList.remove('bg-red-500');
                button.classList.add('bg-secondary');
                status.textContent = 'Stopped';
                speedCheckbox.checked = false;
                if (gameState.aiInterval) {
                    clearInterval(gameState.aiInterval);
                }
            }
        }
        function toggleAISpeed() {
            const checkbox = document.getElementById('ai-speed');
            const slider = checkbox.nextElementSibling.children[0];
            if (checkbox.checked) {
                slider.classList.add('translate-x-4');
                if (gameState.aiRunning) {
                    runAI(50);
                }
            } else {
                slider.classList.remove('translate-x-4');
                if (gameState.aiRunning) {
                    runAI(300);
                }
            }
        }

        function runAI() {
            if (gameState.aiInterval) {
                clearInterval(gameState.aiInterval);
            }
            gameState.aiInterval = setInterval(() => {
                if (!gameState.aiRunning) return;
                const directions = ['up', 'right', 'down', 'left'];
                let bestScore = -1;
                let bestMove = null;
                for (const direction of directions) {
                    const tempBoard = [...gameState.board];
                    const tempScore = gameState.score;
                    if (move(direction)) {
                        const movescore = expectimax(gameState.board, 0, false);
                        gameState.board = tempBoard;
                        gameState.score = tempScore;
                        if (movescore > bestScore) {
                            bestScore = movescore;
                            bestMove = direction;
                        }
                    }
                }

                if (bestMove) {
                    move(bestMove);
                }
            }, 100);
        }

        function expectimax(board, depth, isPlayerTurn) {
            if (depth >= 3 || isGameOver(board)) return heuristicScore(board);

            if (isPlayerTurn) {
                let maxScore = -Infinity;
                const moves = ["up", "down", "left", "right"];
                for (const move of moves) {
                    const newBoard = simulateMove(board, move);
                    if (newBoard) {
                        const score = expectimax(newBoard, depth + 1, false);
                        maxScore = Math.max(maxScore, score);
                    }
                }
                return maxScore;
            } else {
                const emptyTiles = [];
                board.forEach((tile, i) => {
                    if (tile === 0) emptyTiles.push(i);
                });

                if (emptyTiles.length === 0) return heuristicScore(board);

                let total = 0;
                for (const index of emptyTiles) {
                    const for2 = [...board];
                    const for4 = [...board];
                    for2[index] = 2;
                    for4[index] = 4;
                    total += 0.9 * expectimax(for2, depth + 1, true);
                    total += 0.1 * expectimax(for4, depth + 1, true);
                }

                return total / emptyTiles.length;
            }
        }

        function simulateMove(board, direction) {
            const original = [...gameState.board];
            gameState.board = [...board];
            const moved = moveTiles(direction);
            const newBoard = [...gameState.board];
            gameState.board = [...original]; // Restore original game state
            return moved ? newBoard : null;
        }

        function isGameOver(board) {
            const backup = [...gameState.board];
            gameState.board = [...board];
            const over = !["up", "down", "left", "right"].some(move => {
                const test = moveTiles(move);
                gameState.board = [...board]; // Restore
                return test;
            });
            gameState.board = backup;
            return over;
        }

        function heuristicScore(board) {
            let score = 0;
            const weights = [
                [65536, 32768, 16384, 8192],
                [512, 1024, 2048, 4096],
                [256, 128, 64, 32],
                [2, 4, 8, 16]
            ];
            for (let i = 0; i < 16; i++) {
                const row = Math.floor(i / 4);
                const col = i % 4;
                score += board[i] * weights[row][col];
            }
            return score;
        }


        document.addEventListener('keydown', (e) => {
            if (gameState.gameMode !== 'human') return;
            switch (e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    move('right');
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    move('down');
                    break;
            }
        });
        let touchStartX = 0;
        let touchStartY = 0;
        document.querySelector('.game-container').addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        document.querySelector('.game-container').addEventListener('touchend', (e) => {
            if (gameState.gameMode !== 'human') return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) {
                    move('right');
                } else {
                    move('left');
                }
            } else {
                if (dy > 0) {
                    move('down');
                } else {
                    move('up');
                }
            }
        });
        document.getElementById('best-score').textContent = gameState.bestScore;
    </script>
</body>

</html>